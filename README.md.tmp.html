<h1>Ryan Budhu</h1>

<h2>  Section 004</h2>

<h3>1. Binary Search Tree</h3>

<ul>
<li>a) Properties of a BST.
<ul>
<li>Each node has a maximum of two children</li>
<li>The left subtree (all of the nodes coming from and including the left child) must be smaller than the root node</li>
<li>The right subtree (all of the nodes coming from and including the right child) must be greater than the root node</li>
</ul></li>
<li>b) Where n = number of nodes in the BST
<ul>
<li>i. Insert – O(n)
<ul>
<li>Worst case is when BST is a linked-list</li>
</ul></li>
<li>ii. Delete –    O(n)
<ul>
<li>Worst case is when BST is a linked-list</li>
</ul></li>
<li>iii. Find-next –    O(n)
<ul>
<li>Worst case backtrack all nodes</li>
</ul></li>
<li>iv. Find-prev – O(n)
<ul>
<li>Worst case backtrack all nodes</li>
</ul></li>
<li>v. Find-min –   O(n)
<ul>
<li>Must traverse to left most node</li>
</ul></li>
<li>vi. Find-max –  O(n)
<ul>
<li>Must traverse to right most node</li>
</ul></li>
</ul></li>
<li>c) <a href="recursiveTree.py"><code>recursiveTree.py</code></a> ✓
<ul>
<li>i. Create functions of a Binary Search Tree that implement the algorithms recursively.</li>
<li>ii. Input is valid and are integers, and integers are from range -999999 to 999999. There are also no duplicate numbers.</li>
<li>iii. Test Cases
<ul>
<li>Input:
<code>
[2428, 3147, 3222, 30, 7195, 5620, 5934, 2976, 1245, 5021]
</code>
<ul>
<li>Output:
<code>
Root: 2428
Max: 7195
Min: 30
Next: 1245 (Where input is minimum node)
Prev: 5934 (Where input is maximum node)
</code></li>
</ul></li>
</ul></li>
<li>iv. </li>
<li>v. I use a max/min integer to check the minimum and maximum of the tree. Input must be greater than/less than for algorithm to work.</li>
<li>vi. <code>recursiveTree.py</code></li>
<li>vii. Use a different way of comparing for max and min in the tree.</li>
</ul></li>
<li>d) [iterativeTree.py ✓]
<ul>
<li>i. Create functions of a Binary Search Tree that implement the algorithms iteravely.</li>
<li>ii. Input is valid and are integers, and integers are from range -999999 to 999999. There are also no duplicate numbers.</li>
<li>iii. Test Cases
<ul>
<li>Input:
<code>
[6668, 8170, 4097, 2130, 4539, 3772, 482, 8277, 8952, 8451]
</code>
<ul>
<li>Output:
<code>
Root: 6668
Max: 8952
Min: 482
Next: 2130 (Where input is minimum node)
Prev: 8451 (Where input is maximum node)
</code></li>
</ul></li>
</ul></li>
<li>iv. </li>
<li>v. I use a max/min integer to check the minimum and maximum of the tree. Input must be greater than/less than for algorithm to work.</li>
<li>vi. <code>iterativeTree.py</code></li>
<li>vii. Use a different way of comparing for max and min in the tree.</li>
</ul></li>
</ul>

<h3>2. Sort it!</h3>

<ul>
<li>0005, 0006, 0007, 0010, 0011, 0012, 0016, 0017, 0018, 0019, 0020</li>
<li>Insert the values into the BST one at a time, then create an array of a inorder traversal of the BST and output the array.</li>
<li>[<code>BST.py</code> ✓]</li>
</ul>

<h3>3. Arrays of Integers</h3>

<ul>
<li><a href="getRandomArray.py"><code>getRandomArray.py</code></a> ✓</li>
<li><a href="getSortedArray.py"><code>getSortedArray.py</code></a> ✓</li>
</ul>

<h3>4. Balanced Binary Trees</h3>

<ul>
<li>a) Properties of a BBST
<ul>
<li>Each node has a maximum of two children</li>
<li>The left subtree (all of the nodes coming from and including the left child) must be smaller than the root node</li>
<li>The right subtree (all of the nodes coming from and including the right child) must be greater than the root node</li>
<li>A self balancing tree to keep worst case to O(logn) for all operations</li>
<li>Keeps the absolute value of the balance factor at or less than 1</li>
</ul></li>
<li>b) Where n = number of nodes in BBST
<ul>
<li>i. Insert – O(logn)
<ul>
<li>Balancing tree takes constant time</li>
</ul></li>
<li>ii. Delete –    O(logn)
<ul>
<li>Balancing tree takes constant time</li>
</ul></li>
<li>iii. Find-next –    O(logn)
<ul>
<li>Tree is balanced</li>
</ul></li>
<li>iv. Find-prev – O(logn)
<ul>
<li>Tree is balanced</li>
</ul></li>
<li>v. Find-min –   O(logn)
<ul>
<li>Tree is balanced</li>
</ul></li>
<li>vi. Find-max –  O(logn)
<ul>
<li>Tree is balanced</li>
</ul></li>
</ul></li>
<li>c) <a href="recursiveAVL.py"><code>recursiveAVL.py</code></a>✓
<ul>
<li>i. Create functions of a Binary Search Tree that implement the algorithms recursively.</li>
<li>ii. Input is valid and are integers, and integers are from range -999999 to 999999. There are also no duplicate numbers.</li>
<li>iii. Test Cases
<ul>
<li>Input:
<code>
[2428, 3147, 3222, 30, 7195, 5620, 5934, 2976, 1245, 5021]
</code>
<ul>
<li>Output:
<code>
Root: 2428
Max: 7195
Min: 30
Next: 1245 (Where input is minimum node)
Prev: 5934 (Where input is maximum node)
</code></li>
</ul></li>
</ul></li>
<li>iv. </li>
<li>v. I use a max/min integer to check the minimum and maximum of the tree. Input must be greater than/less than for algorithm to work.</li>
<li>vi. <code>recursiveAVL.py</code></li>
<li>vii. Use a different way of comparing for max and min in the tree.</li>
</ul></li>
<li><p>d) <a href="iterativeAVL.py"><code>iterativeAVL.py</code></a>✓</p>

<ul>
<li>i. Create functions of a Binary Search Tree that implement the algorithms iteravely.</li>
<li>ii. Input is valid and are integers, and integers are from range -999999 to 999999. There are also no duplicate numbers.</li>
<li>iii. Test Cases
<ul>
<li>Input:
<code>
[6668, 8170, 4097, 2130, 4539, 3772, 482, 8277, 8952, 8451]
</code>
<ul>
<li>Output:
<code>
Root: 6668
Max: 8952
Min: 482
Next: 2130 (Where input is minimum node)
Prev: 8451 (Where input is maximum node)
</code></li>
</ul></li>
</ul></li>
<li>iv. </li>
<li>v. I use a max/min integer to check the minimum and maximum of the tree. Input must be greater than/less than for algorithm to work.</li>
<li>vi. <code>iterativeAVL.py</code></li>
<li>vii. Use a different way of comparing for max and min in the tree.
<h3>5. Constructing Trees</h3></li>
</ul></li>
<li><p>a) <a href="constructRecursiveTrees.py"><code>constructRecrusiveTrees.py</code></a>✓</p></li>
<li>b) Issues
<ul>
<li>My program did not run into issues when running the program. An issue that may arise could possibly be a stack overflow error in the AVL tree because of the recursion that takes place.</li>
</ul></li>
<li><p>c) <a href="constructIterativeTrees.py"><code>constructIterativeTrees.py</code></a>✓</p>

<h3>6. Compare Implementations</h3></li>
<li><p>a) Modified files to add counter.</p>

<ul>
<li><a href="iterativeAVL.py"><code>iterativeAVL.py</code></a></li>
<li><a href="iterativeTree.py"><code>iterativeTree.py</code></a></li>
</ul></li>
<li><p>b) Screenshots</p>

<ul>
<li><strong>BST</strong> <img src="docs/BST.png" alt="BST image" title="" /></li>
<li><strong>AVL</strong> <img src="docs/AVL.png" alt="AVL image" title="" />
+
<h3>7. Extra Credit</h3></li>
</ul></li>
<li><p>a) Timed constructs</p>

<ul>
<li>Implemented in <a href="constructIterativeTrees.py"><code>constructIterativeTrees.py</code></a></li>
<li>Implemented in <a href="constructRecursiveTrees.py"><code>constructRecursiveTrees.py</code></a></li>
</ul></li>
</ul>
